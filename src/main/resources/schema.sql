-- ===============================================
-- STOCK WATCHLIST DATABASE SCHEMA - FINAL DESIGN
-- Architecture: Normalized Core + Materialized Views for Performance
-- ===============================================

-- ===============================================
-- CORE ENTITIES - FULLY NORMALIZED DESIGN
-- ===============================================

-- Users table - Standard entity design with soft delete support
CREATE TABLE IF NOT EXISTS users (
    user_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255) NOT NULL,
    mobile_number VARCHAR(15) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Stocks table - Master data with natural composite key and soft delete
-- DECISION: Natural composite key (exchange, ticker) over surrogate key
-- RATIONALE: Semantically meaningful, no frequent JOINs needed, stable identifier
CREATE TABLE IF NOT EXISTS stocks (
    exchange VARCHAR(10) NOT NULL,          -- NYSE, NASDAQ, BSE, NSE
    ticker VARCHAR(20) NOT NULL,
    name VARCHAR(100) NOT NULL,             -- Company name for display
    sector VARCHAR(50),
    is_active BOOLEAN DEFAULT TRUE,         -- Soft delete flag for delisted stocks
    delisted_at TIMESTAMP NULL,             -- Audit trail for delisting
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (exchange, ticker)
);

-- Watchlists table - User's named collection of stocks
-- DECISION: ON DELETE SET NULL for creator (not CASCADE)
-- RATIONALE: Preserve watchlists when users delete accounts - may be shared/referenced
CREATE TABLE IF NOT EXISTS watchlists (
    watchlist_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) DEFAULT 'My Watchlist',
    creator BIGINT,                         -- NULL = deleted user
    needs_refresh BOOLEAN DEFAULT FALSE,    -- Materialized view staleness flag
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (creator) REFERENCES users(user_id) ON DELETE SET NULL
);

-- Junction table - Pure normalized many-to-many relationship
-- DECISION: No primary key, no denormalized data
-- RATIONALE:
--   1. Junction tables are just relationships - primary keys add unnecessary complexity
--   2. Denormalization breaks when stocks are soft-deleted (stale data problem)
--   3. Materialized views handle performance concerns
--   4. Unique constraint prevents duplicates without forcing artificial primary key
CREATE TABLE IF NOT EXISTS watchlist_stocks (
    watchlist_id BIGINT NOT NULL,
    stock_exchange VARCHAR(10) NOT NULL,
    stock_ticker VARCHAR(20) NOT NULL,
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_watchlist_stock UNIQUE (watchlist_id, stock_exchange, stock_ticker),
    FOREIGN KEY (watchlist_id) REFERENCES watchlists(watchlist_id) ON DELETE CASCADE,
    FOREIGN KEY (stock_exchange, stock_ticker) REFERENCES stocks(exchange, ticker)
    -- No ON DELETE for stocks - handled via soft delete + materialized view refresh
);

-- ===============================================
-- PERFORMANCE LAYER - MATERIALIZED VIEWS
-- ===============================================

-- Materialized view for fast watchlist display
-- DECISION: Solve denormalization vs consistency with materialized views
-- RATIONALE:
--   1. Fast reads: Pre-computed JOINs eliminate query-time performance cost
--   2. Consistency: Single source of truth in normalized tables
--   3. Flexibility: Can show [DELISTED] status without data corruption
--   4. Staleness acceptable: Financial watchlists can be eventually consistent
CREATE MATERIALIZED VIEW watchlist_display AS
SELECT
    ws.watchlist_id,
    ws.stock_exchange,
    ws.stock_ticker,
    s.name AS stock_name,
    s.sector,
    ws.added_at,
    CASE
        WHEN s.is_active = FALSE THEN CONCAT('[DELISTED] ', s.name)
        ELSE s.name
    END AS display_name,
    s.is_active
FROM watchlist_stocks ws
JOIN stocks s ON ws.stock_exchange = s.exchange AND ws.stock_ticker = s.ticker;

-- ===============================================
-- INDEXING STRATEGY
-- ===============================================

-- Core performance indexes
CREATE INDEX idx_watchlist_display_lookup ON watchlist_stocks(watchlist_id);
CREATE INDEX idx_stocks_sector ON stocks(sector) WHERE is_active = TRUE;

-- Note: No index on boolean is_active field - poor selectivity in B-tree
-- If needed, consider partial index: CREATE INDEX ON stocks(exchange, ticker) WHERE is_active = TRUE;
--
---- ===============================================
---- SCHEMA VERSIONING
---- ===============================================
--
--CREATE TABLE IF NOT EXISTS schema_migrations (
--    version VARCHAR(50) PRIMARY KEY,
--    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
--);

-- ===============================================
-- ARCHITECTURAL DECISIONS SUMMARY
-- ===============================================

-- CORE PHILOSOPHY: "Normalize for correctness, materialize for performance"
--
-- 1. NATURAL KEYS: Used composite (exchange, ticker) because:
--    • Semantically meaningful in financial domain
--    • No frequent JOINs between core entities
--    • Stable identifier (tickers rarely change)
--
-- 2. NO JUNCTION TABLE PRIMARY KEY: Because:
--    • Junction tables represent relationships, not entities
--    • Unique constraint prevents duplicates without artificial complexity
--    • Primary keys on junction tables are often unnecessary overhead
--
-- 3. SOFT DELETE + MATERIALIZED VIEWS: Because:
--    • Denormalization breaks with soft deletes (stale redundant data)
--    • Materialized views provide performance without consistency issues
--    • Can display [DELISTED] status cleanly
--    • Eventual consistency acceptable for this domain
--
-- 4. STALENESS TRACKING: needs_refresh flag because:
--    • Enables smart refresh - only recompute when necessary
--    • Allows graceful degradation during high-load periods
--    • Application can choose fast-stale vs slow-fresh data
--
-- 5. MINIMAL INDEXING: Because:
--    • Over-indexing hurts write performance
--    • Boolean indexes have poor selectivity
--    • Materialized views handle most query optimization needs
--
-- QUERY PATTERNS OPTIMIZED:
-- • Hot path: SELECT * FROM watchlist_display WHERE watchlist_id = ?
-- • Detail path: SELECT * FROM stocks WHERE exchange = ? AND ticker = ?
-- • Maintenance: REFRESH MATERIALIZED VIEW + flag reset via cron
--
-- TRADE-OFFS ACCEPTED:
-- • Eventual consistency vs real-time accuracy
-- • Storage overhead of materialized views vs query performance
-- • Maintenance complexity vs read performance
-- • All consciously chosen based on read-heavy workload characteristics
-- ===============================================